###################################
# Name:         ClientFunction.py
# Description:  Implementation of all the functionality expected of the client.
#               Client is responsible for taking in user input of a quantity for Distance, Weight, or Temperature,
#                   and submit information to the server for conversion
#
# Author: Xander Palermo <ajp2s@missouristate.edu>
# Class: CSC565 - Computer Networking
# Assignment: Socket Programming Assignment 1
####################################

import re
from decimal import InvalidOperation

from share.Message import Message, SUPPORTED_METRIC, SUPPORTED_IMPERIAL
from share.Message import OPTIONS

DIVIDER = '\n' + ('-' * 30) + '\n'





def create_message(connection_type : str, args : list[str]):
    """
    Creates a message dataclass instance that contains all information required by the server API

    Will validate each argument to ensure that the server can process data without exception

    Args:
            - destination: where the server processing the conversion is located (IPv4 or "localhost")
            - value: The number that the user wants to be converted
            - input: Abbreviation of the units the value is currently in
            - output: Abbreviation of the units the user wants the value in
    :param connection_type: Type of connection being established (for logging purposes)
    :param args: A list of arguments passed on by the user (4 in total)
    :return: Message object complete with
    """

    def reject_input(inp: str, reason: str) -> None:
        """
        Informs the user their provided input is invalid
        :param inp: The invalid input provided by the user
        :param reason: The reason the input is considered invalid
        :return: None
        """
        print(f"\nInput invalid ({reason})"
              f"\nYou entered: {inp}"
              f"\nplease try again...\n{DIVIDER}")

    def validate_server(server_location : str) -> str | None:
        """
        validates an IPv4 address of a server
        :param server_location user provided server location
        :return: An IP address of a server (accepts LocalHost)

        ..note
            localhost is also an accepted IPv4 address
        """

        if re.fullmatch(r"\d{,3}\.\d{,3}\.\d{,3}\.\d{,3}",server_location) or server_location == "localhost":
            return server_location

        reject_input(server_location, "Not valid IPv4 address")
        raise RuntimeError()

    def validate_input(inp : str)-> list[int | bool]:
        """
        Validates unit of measurement
        :param inp: an abbrivation of some unit of measurement
        :return:
                an int representation of that measurement.
                a bool representation of if the units are in metric.
        """

        if inp in SUPPORTED_METRIC:
            return [SUPPORTED_METRIC.index(inp), True]
        elif inp in SUPPORTED_IMPERIAL:
            return [SUPPORTED_IMPERIAL.index(inp), False]

        reject_input(inp, "Not valid unit of measure")
        raise RuntimeError()

    def validate_value(inp : str, is_temp : bool) -> float:
        """
        Validates if the input provided by the user can be converted to a float

        If the units are not in temperature, a negative number will be rejected
        :param inp: the user provided value to be converted
        :param is_temp: is the value in inp representative of a temperature
        :return: a float representation of the input provided by the user
        """
        try:
            user_input = float(inp)
        except InvalidOperation:
            reject_input(inp, "not a number")
            exit(0)

        if not is_temp and user_input <= 0:
            reject_input(inp, "non-integer number for this type of conversion")
            exit(0)
        return user_input

    print(f"Starting Client...\n\t(Connection Type: {connection_type}){DIVIDER}")

    """ARG NUMBER"""
    if len(args) != 4:
        reject_input(args, "Invalid Number of arguments")
        raise RuntimeError()

    """SERVER LOCATION"""

    destination = validate_server(args[0])

    """CONVERSION INPUT"""

    inp_type, inp_metric = validate_input(args[2])

    """CONVERSION OUTPUT"""

    out_type, _ = validate_input(args[3])

    if inp_type != out_type:
        reject_input(f"{args[2]}-->{args[3]}", "Unsupported Conversion")
        raise RuntimeError()

    """CONVERSION VALUE"""

    value = validate_value(args[1], inp_type == 2)

    message = Message(header=(inp_type+1, inp_metric),
                      destination=destination,
                      content=value)
    return message

def return_message(request : Message, response : Message) -> None:
    """
    Prints conversion generated by server
    :param request: The message generated by user inputted.
                    (Only the value contented in its content field is used)
    :param response: The message generated by the server
    :return: None

    .. note::
       Precondition — the response header is assumed to match the request header.
       If they differ, the response header is used.
    """
    options_list = list(OPTIONS.values())
    options_list = options_list[response.header[0]]

    current_units = options_list[0] if response.header[1] else options_list[1]
    future_units = options_list[1] if response.header[1] else options_list[0]

    current_units = " " + current_units
    future_units = " " + future_units

    if response.header[0] == 3: #Temperature needs a modifier
        current_units = "° " + current_units
        future_units = "° " + future_units


    print(f"{request.content:,}{current_units} is equal to {response.content:,.4f}{future_units}")



def main():
    #TEST FUNCTIONALITY
    message = create_message("TEST", ["localhost",120,"C","F"])
    return_message(message, message)

if __name__ == "__main__":
    main()